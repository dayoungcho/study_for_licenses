# 1과목 소프트웨어 설계
- 결합도: 서로 다른 두 모듈 간의 상호 의존도
  - 자료 결합도: 모듈 간의 인터페이스가 자료 요소로만 구성된 경우 -> 가장 약함
  - 내용 결합도: 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 조회하도록 설계되었을 경우 -> 가장 강함
  - UML확장 모델에서 스테레오 타입 객체 : << >> 기호 사용
  - 자료흐름도(Data Flow Diagram)의 구성 요소
    - 프로세스, 자료 흐름, 자료 저장소, 단말 (process, data flow, data store, terminator)
- 메시지 지향 미들웨어(Message-Oriented Middleware)
  - 메시지를 기반으로 하는 비동기식 메시지 전달 보장 방식 미들웨어
  - 이기종 분산 데이터베이스 시스템에서 데이터 동기화에 주로 사용(독립적 앱을 하나의 시스템으로 묶음)
  - 느리고 안정적 응답
  - 송신/수신 연결 시 메시지 큐 활용가능

 - MVC(Model View Controller)
   - 소프트웨어 아키텍처 모델 중 하나
   - 사용자 인터페이스 담당 계층의 응집도를 높임
   - 여러 개의 다른 UI를 만들어 그 사이에 결합도를 낮출 수 있음
   -구성요소
     - 모델: 데이터와 비즈니스 로직 관리
     - 뷰: 레이아웃과 화면 처리
     - 컨트롤러: 명령을 모델과 뷰 부분으로 라우팅 / 모델에 명령을 보내서 모델의 상태 변경 가능
   - 
# 2과목 소프트웨어 개발
- 테스트 오라클: 테스트의 결과가 참인지 거짓인지 판단하기 위해 사전에 정의된 참(True)값을 입력하여 비교
  1) 참 오라클: 모든 입력값에 대해 적합한 결과 제공
  2) 일관성 검사 오라클: 애플리케이션의 변경이 있을 때 테스트 케이스의 수행 전후 결과값이 동일한지 확인하는 오라클
  3) 샘플링 오라클: 특정 몇몇 입력값에 대해서만 기대하는 결과 제공
  4) 휴리스틱 오라클: 특정 몇몇 입력값에 대해서만 기대하는 결과를 제공하고, 나머지 값들에 대해선 추정으로 처리
- 스택의 응용 분야
  - 함수 호출 스택
  - 후위 표기법 변환(수식 계산)
  - 컴파일러
  - 운영체제 인터럽트 처리
  -  서브루틴 복귀 번지 저장
- 인터페이스 구현 검증 도구: xUnit, STAF, NTAF,FitNesse 등
- 연결 리스트
  - 데이터와 포인터로 이루어진 노드를 연결
  - 노드의 삽입, 삭제가 쉬움
  - 포인터를 위한 추가 공간 필요
  - 선형 리스트에 비해 검색 속도가 느림
  - 중간 노드 연결이 끊어지면 그 다음 노드를 찾기 어려움
- 네트워크 보안: IPSec, IKE, S-HTTP
- 형상 관리
  소프트웨어 버전 등록 관련 주요 용어
  - 저장소(Repository) : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳
  - 가져오기(Import) : 버전 관리가 되고 있지 않은 아무것도 없는 저장소에 처음으로 파일을 복사
  - 체크아웃(Check-Out) : 프로그램을 수정하기 위해 저장소에서 파일을 받아 옴. 소스 파일과 함께 버전 관리를 위한 파일들도 받음
  - 체크인(Check-In) : 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신
  - 커밋(Commit) : 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우 충돌을 알리고 diff 도구를 이용해 수정 후 갱신 완료
  - 동기화(Update) : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화함

- 디지털 저작권 관리(DRM) 기술 요소: 암호화, 키 관리, 암호화 파일 생성, 식별 기술, 저작권 표현, 정책 관리, 크랙 방지, 인증, 인터페이스, 이벤트 보고, 사용 권한
파티션 유형
  - 범위 분할(Range Partitioning) : 지정한 열의 값을 기준으로 분할
  - 해시 분할(Hash Partitioning) : 해시 함수를 적용한 결과 값에 따라 데이터 분할
  - 조합 분할(Composite Partitioning) : 범위 분할 후 해시 함수를 적용하여 다시 분할
- 해싱 함수 종류
  - 폴딩법 - 해싱함수  중 레코드 키를 여러부분으로 나누고 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용
  - 제산법 - 레코드키를 해시표로 나눈 나머지를 홈 주소로 사용
  - 기수변환법 - 키 숫자의 진수를 다른 진수로 변환시켜 주소 크기를 초과한 높은 자릿수 절단, 다시 주소 범위에 맞게 조정
  - 숫자분석법 - 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 선택
  - 중간제곱법
- 워크스루
  - 개발자가 동료들에게 자신이 개발한 코드를 설명하면서 검토
  - 인스펙션은 워크스루를 발전시킨 형태
  - 단순한 테스트 케이스를 이용하여 프로덕트를 수작업으로 수행
# 3과목 데이터베이스 구축
- 분산 데이터베이스: 네트워크를 통해 연결된 여러 개의 컴퓨터에 데이터가 분산된 데이터베이스
  - 위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성을 목표로 함
  - 데이터베이스 설계 및 소프트웨어 개발이 어려움
  - 중앙 서버 통제 없이 지역 서버 고유 데이터 작업 가능
  - 새로운 지역 서버 추가, 장비 추가 등의 작업이 용이
 
- 분할 키 기준 분할(파티셔닝) 유형
  1) 범위 분할(Range Partitioning): 지정한 열 값 기준으로 범위 지정하여 분할
  2) 목록 분할(List Partitioning): 할당 분할 키 값(카테고리 등)을 그 목록에 비추어 파티션 선택
  3) 해시 분할(Hash Partitioning): 해시 함수의 값에 따라 분할
  4) 합성 분할(Composite Partitioning): 범위, 목록, 해시 분할을 결합
  5) 라운드로빈 분할(Round Robin Partitioning): 파티션에 행의 고른 분포를 원할 때 사용
 
- 정규화
  1) 1NF: 모든 **도**메인이 원자값
  2) 2NF: **부**분적 함수 종속 X -> 완전 함수적 종속
  3) 3NF: **이**행적 함수 종속 X
  4) BCNF: **결**정자이면서 후보키가 아닌 함수 종속 X
  5) 4NF: **다**치 종속 X
  6) 5NF: **조**인 종속 X
 
- 키의 종류
  1) 슈퍼키: 튜플을 고유하게 식별하는 속성들의 집합 (유일성 O, 최소성 X)
  2) 후보키: 슈퍼키 중에서 기본키로 선택될 수 있는 속성들의 집합 (유일성 O, 최소성 O)
  3) 기본키: 튜플을 고유하게 식별하는 주요 속성
  4) 대체키: 후보키 중 기본키로 선택되지 않은 나머지 속성
  5) 외래키: 다른 테이블의 기본키로 사용되는 속성
- CRUD 분석: 데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제연산(Create, Read, Update, Delete)으로 프로세스와 테이블 간에 매트랙스를 만들어서 트랜잭션을 분석하는 것 
- SQL
  - DDL
    1) CREATE
    2) ALTER
    3) DROP
  - DCL
    1) COMMIT
    2) ROLLBACK
    3) GRANT
    4) REVOKE
  - DML
    1) SELECT
    2) INSERT
    3) UPDATE
    4) DELETE
    5) TRUNCATE
       - 롤백을 통해 이전 상태로 돌아갈 수 없음
       - 테이블의 데이터만 삭제함(DROP은 테이블도 삭제)
       - WHERE 조건절 사용 불가
       - DELETE보다 처리 속도 빠름


# 4과목 프로그래밍언어 활용
- JAVA
- 가상 기억 장치
  - 페이지 부재: 참조할 페이지가 주기억장치에 없는 현상
  - 워킹 셋(Working Set): 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
  - 스래싱(Thrashing): 지나치게 페이지 부재가 발생하여 프로세스 수행 시간 < 페이지 이동 시간 이 되는 현상
- 프로세스
  - 실행 중인 프로그램
  - 비동기적 행위를 일으키는 주체
  - 프로세서가 할당되는 실체
  - 디스패치 가능
  - 실해할 수 있는 PCB(프로세스 제어 블록)을 가짐
  - 스레드: 프로세스 내의 작업단위
- OSI 7계층
  1) 물리
  2) 데이터 링크
     - 프로토콜 데이터 단위(PDU) = 프레임
     - 인접 통신 시스템 간 (노드와 노드 사이) 프레임 전송
  4) 네트워크
     - 통신망을 통해 패킷을 목적지까지 전달
     - 패킷에 발신지와 목적지의 논리 주소 추가
     - 프로토콜 데이터 단위(PDU) = 패킷
     - 라우터/교환기: 패킷 전달을 위한 경로 지정, 교환 기능 제공
  5) 전송
  6) 세션
  7) 표현
  8) 응용
- 프로세스 스케줄링
  - 추가할것,,,
# 5과목 정보 시스템 구축관리




#include <stdio.h>

int main(int argc, char* argv[ ]) {

int a[ ] = { 14,22,30,38 };

printf(“%u, ”, &a[2]);

printf(“%u”, a);


사용된 코드의 의미는 다음과 같습니다.

#include <stdio.h>

int main(int argc, char* argv[ ]) {

❶ int a[ ] = { 14,22,30,38 };

❷ printf(“%u, ”, &a[2]);

❸ printf(“%u”, a);

❹ return 0;

}

❶ 4개의 요소를 갖는 정수형 배열 a를 선언하고 초기화한다.

❷ a[2]가 가리키는 주소를 부호없는 정수형으로 출력하고, 이어서 쉼표(,)와 공백 한 칸을 출력한다. a[0]의 주소가 10이고, 정수형(int)의 크기가 4Byte이므로 a[2]의 주소 18, 이 출력된다.



결과 18,

❸ a를 부호없는 정수형으로 출력한다. 배열의 이름은 배열의 시작 주소를 가리키므로 10이 출력된다.

결과 18, 10

❹ main( ) 함수에서의 ‘return 0’은 프로그램의 종료를 의미한다.

return 0;

}
